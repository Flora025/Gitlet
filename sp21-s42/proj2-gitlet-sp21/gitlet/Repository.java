package gitlet;import org.checkerframework.checker.units.qual.C;import java.io.File;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.*;import static gitlet.Utils.*;import static gitlet.Utils.plainFilenamesIn;/** Represents a gitlet repository. *  File structure is as follows (flattened and simplified compared with .git): *  .gitlet *      |--commits/ *      |--blobs/ *      |--branchHeads/ *      |    |--Master        # Master branch *      |    |--anotherBranch # some other branches *      |--HEAD *      |--add                # staged addition *      |--rm                 # staged removal *  Abstraction principle: Involve only communications between Objects and avoid lower map/hash/pointer operations *  @author flora */public class Repository {    /* Directories */    /** The current working directory. */    public static final File CWD = new File(System.getProperty("user.dir"));    /** The .gitlet directory. */    public static final File GITLET_DIR = join(CWD, ".gitlet");    /** The directory in .gitlet/ which stores the heads of branches (incl. Master and others). */    public static final File BRANCH_DIR = join(GITLET_DIR, "branchHeads");    /* Files */    // Note: all pointers are represented as hashcode and stored in Files.    /** The file in .gitlet/ which stores the Commit that HEAD is pointing to. */    public static File HEAD = join(GITLET_DIR, "HEAD");    /** The File in .gitlet/ which stores the Commit Master is pointing to. */    public static File Master = join(BRANCH_DIR, "Master");    /** Staging area for addition. Data are saved as a Map object*/    public static StagingArea Add;    /** Staging area for removal */    public static StagingArea Rm;    private static String curBranchName;    /* Commands */    private static void initDirs() throws IOException {        GITLET_DIR.mkdir();        BRANCH_DIR.mkdir();        HEAD.createNewFile();        Master.createNewFile();        Add = new StagingArea("Add");        Rm = new StagingArea("Rm");        curBranchName = "Master";    }    /** Initialize .gitlet repository in the current directory. */    public static void init() throws IOException {        // Exit program if gitlet vcs already exists        if (GITLET_DIR.exists()) {            Utils.message("A Gitlet version-control system already exists in the current directory.");            return;        }        System.getProperty("user.dir");        // 1. Create dirs and files        initDirs();        // 2. Create and save the first Commit        Commit firstCommit = new Commit("initial commit", null, new HashMap<>(), new Date(0));        firstCommit.saveCommit();        // 3. Initialize HEAD and master pointers        updatePointerTo(HEAD, firstCommit); // designate HEAD -> initCommit        updatePointerTo(Master, firstCommit); // designate Master -> initCommit    }    /** Given the plain name of a file,     *  if the file has been changed, add a mapping to the staging area.     *  @implNote The mapping is represented as {"plainName": "reference to the file's Blob hash"}.     *     *  @param plainName Plain name of the file. E.g. Hello.txt */    public static void add(String plainName) {        File curFile = join(CWD, plainName);        if (!curFile.exists()) {            message("File does not exist.");            System.exit(0);        }        // Read in the file as a Blob        Blob curBlob = new Blob(curFile, plainName); // the file's cur blob        curBlob.saveBlob();        // Compare the [current Blob] and the [Blob of the HEAD Commit] of the same plainName        Commit curHead = getPointer(HEAD);        Blob headBlob = curHead.get(plainName); // the file's blob in HEAD commit        // If this id does not match the id of the same file in the HEAD (i.e. cur) commit        //    || there is no such file in the HEAD commit,        // -> the file is changed || newly added, update the mapping        if (headBlob == null || !curBlob.compareTo(headBlob)) {            // Add the new mapping to staging area for addition (Add)            Add.put(plainName, curBlob);        }        // Else if the two matches -> No changes in the file, and thus nothing happens    }    /**     * Saves a snapshot of tracked files in the current commit and staging area.     * Save and start tracking any files that were staged for addition but were not tracked by its parent.     * @param message Commit message.     */    public static void commit(String message) {        // Failure cases: if no file has been staged        if (Add.size() == 0) {            message("No changes added to the commit.");            System.exit(0);        }        // Clone the parent Commit and update meta data        Commit parentCommit = getPointer(HEAD);        Commit curCommit = new Commit(message, parentCommit.getId(), parentCommit.getMap(), new Date()); // receives a copy of parent's map        /** @implNote:         * Rm records files once `staged` and just deleted from the WD.         * The files are no longer in the WD, but are not yet updated in the Commit mappings.*/        // Update current Commit according to staged addition and removal        curCommit.updateCommitMapTo(Add);        curCommit.updateCommitMapTo(Rm);        curCommit.saveCommit();        // Update HEAD and MASTER pointers        updatePointerTo(HEAD, curCommit);        updatePointerTo(Master, curCommit);        // Clean the staging area (Add && Rm)        Add.clean();        Rm.clean();    }    /**     * Unstage the file if it is currently staged for addition.     * If the file is tracked in the current commit,     *   stage it for removal and remove the file from the working directory     * @param plainName The plain name of the file to be removed.     */    public static void rm(String plainName) {        Commit head = getPointer(HEAD);        boolean isStaged = Add.containsFile(plainName); // staged in Add or not        boolean isTracked = head.containsFile(plainName); // tracked or not        // Failure cases: if the file is neither `staged` nor `tracked`        if (!isStaged && (!isTracked)) {            message("No reason to remove the file.");            System.exit(0);        }        // If the file exists in stagedAddition,        // remove it from add and add to stagedRemoval        if (isStaged) {            // remove from Add            Blob blob = Add.remove(plainName);            // put into Rm            Rm.put(plainName, blob);        }        // If the file is tracked in curCommit[HEAD],        // remove it from the working directory        if (isTracked) {            File delFile = join(CWD, plainName); // abs path of the file to be deleted            restrictedDelete(delFile);        }    }    /**     *  Display information about each commit backwards     *    along the commit tree until the initial commit.     *  This command will follow the first parent commit links     *    and ignore any second parents found in merge commit.     *  c.f. `git log --first-parent`     */    public static void log() {        // util        SimpleDateFormat sdf = new SimpleDateFormat("EEE MMM d HH:mm:ss yyyy Z", new Locale("en", "US"));        Commit curCommit = getPointer(HEAD); // starting from HEAD, walking backwards        while (curCommit != null) {            // For each Commit, print out log info            printCommitInfo(curCommit, sdf);            curCommit = curCommit.getParent();        }    }    /** Displays information about all commits ever made. */    public static void globalLog() {        SimpleDateFormat sdf = new SimpleDateFormat("EEE MMM d HH:mm:ss yyyy Z", new Locale("en", "US"));        List<String> fileIds = plainFilenamesIn(Commit.COMMIT_FOLDER);        assert fileIds != null;        for (String id : fileIds) {            // For each Commit, print out its log info            Commit curCommit = Commit.getCommitFromId(id);            printCommitInfo(curCommit, sdf);        }    }    /**     *  Prints out the ids of all commits that have the given commit message.     * @param message Commit message.     */    public static void find(String message) {        // Get the full list of commit ids        List<String> fileIds = plainFilenamesIn(Commit.COMMIT_FOLDER);        assert fileIds != null;        // For each Commit, if its message == given message        // Print out its id        boolean found = false;        for (String id : fileIds) {            Commit curCommit = Commit.getCommitFromId(id);            if (message.equals(curCommit.getMessage())) {                found = true;                message(id);            }        }        if (!found) {            message("Found no commit with that message.");        }    }    /** Displays what branches currently exist, and marks the current branch with a *. */    public static void status() {        // Print all branches, with current branch marked with a *        message("=== Branches ===");        List<String> branches = plainFilenamesIn(BRANCH_DIR);        assert branches != null;        Commit head = getPointer(HEAD);        for (String branchName : branches) {            // For each branch, print out its name,            // and marks the current branch with a *.            message(branchName.equals(curBranchName) ? ("*" + branchName) : branchName);        }        message("");        // Print all files staged for addition        message("=== Staged Files ===");        Set<String> addFiles = Add.getFiles();        for (String f : addFiles) {            message(f);        }        message("");        // Print all files staged for removal (i.e. removed files)        message("=== Removed Files ===");        Set<String> rmFiles = Rm.getFiles();        for (String f : rmFiles) {            message(f);        }        message("");        message("=== Modifications Not Staged For Commit ===");        message("");        message("=== Untracked Files ===");        message("");    }    /**     * A general command that can fulfil three purposes.     * Usage:     * 1. Takes the version of the file as it exists in the head commit and puts it in the working directory     *    java gitlet.Main checkout -- [file name]     * 2. Takes the version of the file as it exists in the commit with the given id, and puts it in the working directory     *    java gitlet.Main checkout [commit id] -- [file name]     * 3. Takes all files in the commit at the head of the given branch, and puts them in the working directory     *    java gitlet.Main checkout [branch name] */    public static void checkoutHeadFile(String plainName) {        // Get head Commit        Commit head = getPointer(HEAD);        // Get the file's blob version (content)        Blob headBlob = head.get(plainName);        if (headBlob != null) {            // Put it in the WD (not staged)            headBlob.writeContentToFile(join(CWD, plainName));        }        else {            // Failure case:file does not exist            message("File does not exist in that commit.");            System.exit(0);        }    }    public static void checkoutSpecifiedFile(String commitId, String plainName) {        // 1. Get specified Commit        Commit commit = Commit.getCommitFromId(commitId);        if (commit == null) {            // Failure case: commit does not exist            message("No commit with that id exists.");            System.exit(0);        }        // 2. Get the file's blob (content)        Blob commitBlob = commit.get(plainName);        if (commitBlob != null) {            // 3. Put it in the WD (not staged)            commitBlob.writeContentToFile(join(CWD, plainName));        }        else {            // Failure case:file does not exist            message("File does not exist in that commit.");            System.exit(0);        }    }    public static void checkoutBranch(String branchName) throws IOException {        File branchPath = join(BRANCH_DIR, branchName);        Commit head = getPointer(HEAD);        // Failure Cases:        if (!branchPath.exists()) {            // 1. the branch does not exist            message("No such branch exists.");            System.exit(0);        } else if (getPointer(branchPath).compareTo(head)) {            // 2. the checked out branch is the current branch            // FIXME: did not really compare curBranch and headBranch here.            //  What if head does not point to branch head?            message("No need to checkout the current branch.");            System.exit(0);        } else if (hasUntrackedFile(curBranchName, branchName)) {            // 3. if a working file is untracked in the current branch and would be overwritten by the checkout            message("There is an untracked file in the way; delete it, or add and commit it first.");            System.exit(0);        }        // Get branch head Commit's id -> commitId        Commit branchHead = getPointer(branchPath);        String commitId = branchHead.getId();        /* There are 3 kinds of situations: */        // Iterate over files in CWD        for (String plainName : Objects.requireNonNull(plainFilenamesIn(CWD))) {            // 1) the file is tracked in curBranch as well as checked-out branch -> replace the Blob            if (head.containsFile(plainName) && branchHead.containsFile(plainName)) {                // Call checkoutSpecifiedFile(commitId, plainName) on the file                checkoutSpecifiedFile(commitId, plainName);            }            // 2) the file is not tracked in the checkedout branch, but only curBranch -> delete the file            else if (head.containsFile(plainName) && !branchHead.containsFile(plainName)) {                File f = join(CWD, plainName);                restrictedDelete(f);            }            // 3) the file is tracked in the checkedout branch, but not in curBranch -> write the f to cwd            else if (!head.containsFile(plainName) && branchHead.containsFile(plainName)) {                File f = join(CWD, plainName);                Blob content = branchHead.get(plainName);                content.writeContentToFile(f);                f.createNewFile();            }        }        // Set Head to point to the Commit of this branchHead        updatePointerTo(HEAD, branchHead);        // If branchName != the current branch (i.e. if it's checking out to another branch),        // Clear the staging area.        Add.clean();        Rm.clean();    }    /** Creates a new branch with the given name, and points it at the current head commit.     *  Does NOT immediately switch to the newly created branch. */    public static void branch(String name) throws IOException {        // Create a new branch        File newBranch = join(BRANCH_DIR, name);        // Failure case: branch name already exists        if (newBranch.exists()) {            message("A branch with that name already exists.");        } else {            newBranch.createNewFile();        }        // Point it at the cur HEAD Commit        Commit headCommit = getPointer(HEAD);        updatePointerTo(newBranch, headCommit);    }    /** Deletes the branch with the given name.     *  (deletes the pointer and nothing else) */    public static void rmBranch(String branchName) {        File branchPath = join(BRANCH_DIR, branchName);        if (!branchPath.exists()) {            // Failure case 1: branch with the given name does not exist            message("A branch with that name does not exist.");        } else if (branchName.equals(curBranchName)) {            // Failure case 2: trying to remove the current branch            message("Cannot remove the current branch.");        }        restrictedDelete(branchPath);    }    /* HEAD and Branch management */    /** get String info of HEAD commit, tmp used for testing */    private static String getHeadInfo() {        Commit head = getPointer(HEAD);        return head.getData();    }    /** Gets the Commit that a given pointer P is pointing to.     *  Usage: getPointer(HEAD), getPointer(Master) */    private static Commit getPointer(File p) {        String id = readContentsAsString(p);        return Commit.getCommitFromId(id);    }    /** Updates a pointer P to point to a specific Commit     *  Usage: updatePointerTo(HEAD, commit) HEAD -> commit     *         updatePointerTo(Master, commit) Master -> commit*/    private static void updatePointerTo(File p, Commit commit) {        // update by internally overwriting the hash (i.e. filename) of the Commit        writeContents(p, commit.getId());    }    /* Helper Methods */    /** Prints the log information with a given format. */    private static void printCommitInfo(Commit commit, SimpleDateFormat format) {        message("===");        message("commit %s", commit.getId());        // TODO: placeholder for <merge>        // Merge: [first seven digits of the CW branch] [first seven digits of merged-in branch]        // message("Merge: " + format.format(commit.getTimestamp()));        message("Date: " + format.format(commit.getTimestamp()));        message(commit.getMessage() + "\n");    }    /** Check if there are untracked files in the current branch */    private static boolean hasUntrackedFile(String curBranch, String checkoutBranch) {        // Check if this file exists in CWD but not in the Commit of current branch head        Commit curHead = getPointer(join(BRANCH_DIR, curBranch));        Commit checkoutHead = getPointer(join(BRANCH_DIR, checkoutBranch));        // for all files in the current dir,        for (String plainName : Objects.requireNonNull(plainFilenamesIn(CWD))) {            // if the file does not exist in current commit -> has untracked file            if (!curHead.containsFile(plainName)) {                return true;            }        }        return false;    }}